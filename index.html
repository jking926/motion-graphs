<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Motion Graph Maker (Piecewise a)</title>
  <style>
    :root { --ink:#1f2937; --line:#2563eb; --grid:#e5e7eb; --axis:#111827; --bg:#ffffff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; color:var(--ink); background:#f8fafc; }
    .wrap { max-width:1100px; margin:24px auto; padding:0 12px; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:16px; box-shadow: 0 1px 2px rgba(0,0,0,.04); padding:16px; }
    .grid { display:grid; gap:16px; }
    @media (min-width: 900px) { .grid-2 { grid-template-columns: 1fr 1fr; } }
    table { width:100%; border-collapse: collapse; }
    th, td { padding:8px; border-bottom:1px solid #eef2f7; font-size:14px; }
    th { text-align:left; color:#475569; }
    input[type="number"], select { width:100%; padding:7px 9px; border:1px solid #d1d5db; border-radius:10px; font-size:14px; background:#fff; }
    label { font-size:12px; color:#64748b; display:block; margin-bottom:4px; }
    .row { display:flex; gap:12px; align-items:center; }
    .btnrow { display:flex; gap:8px; flex-wrap:wrap; }
    button { appearance:none; border:1px solid #cbd5e1; background:#fff; color:#111827; padding:6px 10px; border-radius:10px; font-size:13px; cursor:pointer; }
    button.primary { background:#111827; color:#fff; border-color:#111827; }
    .muted { color:#64748b; font-size:12px; }
    .title { font-size:22px; font-weight:600; margin:0 0 6px; }
    .subtitle { color:#475569; margin:0 0 16px; }
  </style>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="app" class="wrap"></div>

  <script type="text/babel">
    const { useMemo, useRef, useState } = React;

    // -------------------- PHYSICS CORE --------------------
    function integratePiecewise({ x0, v0, segments, samplesPerSecond = 60 }) {
      const totalT = segments.reduce((s, seg) => s + (+seg.duration || 0), 0);
      const dt = totalT > 0 ? 1 / samplesPerSecond : 0.016;
      const boundaries = [{ t: 0, x: +x0, v: +v0 }];
      let t = 0, x = +x0, v = +v0;
      for (const seg of segments) {
        const dur = +seg.duration || 0;
        const a = +seg.a || 0;
        const xEnd = x + v * dur + 0.5 * a * dur * dur;
        const vEnd = v + a * dur;
        t += dur; x = xEnd; v = vEnd;
        boundaries.push({ t, x, v });
      }
      const evalAt = (tt) => {
        let cum = 0, px = +x0, pv = +v0;
        for (const seg of segments) {
          const dur = +seg.duration || 0;
          const a = +seg.a || 0;
          if (tt <= cum + dur + 1e-12) {
            const tau = tt - cum;
            const x = px + pv * tau + 0.5 * a * tau * tau;
            const v = pv + a * tau;
            return { x, v, a };
          }
          const xEnd = px + pv * dur + 0.5 * a * dur * dur;
          const vEnd = pv + a * dur;
          cum += dur; px = xEnd; pv = vEnd;
        }
        const last = boundaries[boundaries.length - 1];
        return { x: last.x, v: last.v, a: 0 };
      };
      const N = Math.max(2, Math.ceil(totalT / dt) + 1);
      const tArr = Array.from({ length: N }, (_, i) => (i * totalT) / (N - 1));
      const xArr = [], vArr = [], aArr = [];
      for (const tt of tArr) {
        const { x, v, a } = evalAt(tt);
        xArr.push(x); vArr.push(v); aArr.push(a);
      }
      const aSteps = [];
      let cum = 0;
      for (const seg of segments) {
        const a = +seg.a || 0, dur = +seg.duration || 0;
        aSteps.push([cum, a], [cum + dur, a]);
        cum += dur;
      }
      return { tArr, xArr, vArr, aArr, aSteps, totalT };
    }

    // -------------------- CHART UTILS --------------------
    function niceStep(raw) {
      const exp = Math.floor(Math.log10(raw));
      const frac = raw / Math.pow(10, exp);
      const niceFrac = frac < 1.5 ? 1 : frac < 3 ? 2 : frac < 7 ? 5 : 10;
      return niceFrac * Math.pow(10, exp);
    }
    function makeTicks(min, max, count=5) {
      const span = max - min || 1;
      const step = niceStep(span / count);
      const start = Math.ceil(min / step) * step;
      const ticks = [];
      for (let v = start; v <= max + 1e-9; v += step) ticks.push(+v.toFixed(10));
      return ticks;
    }
    function makeTicksWithStep(min, max, step) {
      const s = Math.abs(+step || 0);
      if (!(s > 0)) return makeTicks(min, max);
      const start = Math.ceil(min / s) * s;
      const ticks = [];
      for (let v = start; v <= max + 1e-9; v += s) ticks.push(+v.toFixed(10));
      return ticks;
    }
    const fmtFixed = (n, dp) => Number(n).toFixed(dp);
    const fmtSmart = (n) => {
      const a = Math.abs(n);
      if (a === 0) return "0";
      if (a >= 1000 || a < 0.01) return n.toExponential(0);
      if (a >= 10) return n.toFixed(0);
      if (a >= 1) return n.toFixed(1);
      return n.toFixed(2);
    };
    function stepPath(points) {
      if (!points.length) return "";
      let d = `M${points[0][0]},${points[0][1]}`;
      for (let i = 1; i < points.length; i++) {
        const [x, y] = points[i];
        d += ` L${x},${y}`;
      }
      return d;
    }
    async function exportSvgToPng(svgEl, filename, width, height) {
      const clone = svgEl.cloneNode(true);
      clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      const str = new XMLSerializer().serializeToString(clone);
      const blob = new Blob([str], { type:"image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      await new Promise(res => { img.onload = res; img.src = url; });
      const canvas = document.createElement("canvas");
      canvas.width = width * 2; canvas.height = height * 2;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#fff"; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      canvas.toBlob(b => {
        const url2 = URL.createObjectURL(b);
        const a = document.createElement("a");
        a.href = url2; a.download = filename; a.click();
        URL.revokeObjectURL(url2);
        URL.revokeObjectURL(url);
      });
    }

    // -------------------- CHART COMPONENT --------------------
    function Chart({
      data, xLabel, yLabel, title,
      height = 320, padding = 100, yIsStep = false,
      decimalsX = null, decimalsY = null,
      tickStepX = null, tickStepY = null
    }) {
      const svgRef = useRef(null);
      const width = 560;
      // line thickness settings
      const LINE_WIDTH_DATA = 2;     // thickness of the blue motion curve
      const LINE_WIDTH_AXIS = 1;     // thin vertical/horizontal axes
      const LINE_WIDTH_AXIS_ZERO = 2.5; // thick line at y=0
      const LINE_WIDTH_GRID = 0.8;   // light grid lines
      const LINE_WIDTH_TICKS = 1;    // small tick marks at ends of axes


      // fonts & spacing
      const TICK_FONT = 18;
      const AXIS_FONT = 24;
      const X_TICK_OFFSET = 20;   // below axis baseline
      const X_LABEL_OFFSET = 10;  // extra gap below tick numbers
      const Y_TICK_OFFSET = 12;   // left of axis baseline
      const Y_LABEL_OFFSET = 60;  // extra gap left of tick numbers

      const xs = data.map(d => d[0]), ys = data.map(d => d[1]);
      let xmin = Math.min(...xs), xmax = Math.max(...xs);
      let ymin = Math.min(...ys), ymax = Math.max(...ys);
      if (ymin === ymax) { ymin -= 1; ymax += 1; }

      const w = width - padding*2, h = height - padding*2;
      const xTo = x => padding + ((x - xmin) / (xmax - xmin || 1)) * w;
      const yTo = y => height - padding - ((y - ymin) / (ymax - ymin || 1)) * h;

      const points = data.map(([x,y]) => [xTo(x), yTo(y)]);
      const xTicks = tickStepX ? makeTicksWithStep(xmin, xmax, tickStepX) : makeTicks(xmin, xmax, 6);
      const yTicks = tickStepY ? makeTicksWithStep(ymin, ymax, tickStepY) : makeTicks(ymin, ymax, 5);

      const yZero = (0 >= ymin && 0 <= ymax) ? yTo(0) : (height - padding);
      const fmtX = v => (decimalsX===null ? fmtSmart(v) : fmtFixed(v,decimalsX));
      const fmtY = v => (decimalsY===null ? fmtSmart(v) : fmtFixed(v,decimalsY));

      return (
        <div className="card">
          <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:8}}>
            <div style={{fontWeight:600}}>{title}</div>
            <div className="btnrow">
              <button onClick={()=>exportSvgToPng(svgRef.current, `${title}.png`, width, height)}>Download PNG</button>
            </div>
          </div>
          <svg ref={svgRef} width={width} height={height} style={{background:"#fff", borderRadius:12}}>
            {/* axes */}
            <line x1={padding} y1={padding} x2={padding} y2={height-padding} stroke="#111827" strokeWidth={LINE_WIDTH_AXIS} />
            <line x1={padding} y1={yZero} x2={width-padding} y2={yZero} stroke="#111827" strokeWidth={LINE_WIDTH_AXIS_ZERO} />


            {/* grid & ticks */}
            {xTicks.map((tx,i)=>(
              <g key={"xt"+i}>
                <line x1={xTo(tx)} y1={padding} x2={xTo(tx)} y2={height-padding} stroke="#e5e7eb" strokeWidth={LINE_WIDTH_GRID} />
                <line x1={xTo(tx)} y1={height-padding} x2={xTo(tx)} y2={height-padding+6} stroke="#111827" strokeWidth={LINE_WIDTH_TICKS} />
                <text x={xTo(tx)} y={height - padding + X_TICK_OFFSET} fontSize={TICK_FONT} textAnchor="middle" fill="#444">{fmtX(tx)}</text>
              </g>
            ))}
            {yTicks.map((ty,i)=>(
              <g key={"yt"+i}>
                <line x1={padding} y1={yTo(ty)} x2={width-padding} y2={yTo(ty)} stroke="#e5e7eb" strokeWidth={LINE_WIDTH_GRID} />
                <line x1={padding-6} y1={yTo(ty)} x2={padding} y2={yTo(ty)} stroke="#111827" strokeWidth={LINE_WIDTH_TICKS} />
                <text x={padding - Y_TICK_OFFSET} y={yTo(ty)+4} fontSize={TICK_FONT} textAnchor="end" fill="#444">{fmtY(ty)}</text>
              </g>
            ))}

            {/* axis labels */}
            <text
              x={width/2}
              y={height - padding + X_TICK_OFFSET + AXIS_FONT + X_LABEL_OFFSET}
              fontSize={AXIS_FONT}
              textAnchor="middle"
              fill="#333"
            >{xLabel}</text>

            <g transform={`translate(${padding - (Y_TICK_OFFSET + Y_LABEL_OFFSET)}, ${height/2}) rotate(-90)`}>
              <text fontSize={AXIS_FONT} textAnchor="middle" dominantBaseline="central" fill="#333">{yLabel}</text>
            </g>

            {/* data */}
            <path d={stepPath(points)} fill="none" stroke="#2563eb" strokeWidth={LINE_WIDTH_DATA} />
          </svg>
        </div>
      );
    }

    // -------------------- APP --------------------
    function App() {
      const [x0, setX0] = useState(0);
      const [v0, setV0] = useState(2);
      const [segments, setSegments] = useState([{ duration: 2, a: 0 }, { duration: 2, a: -1 }, { duration: 1.5, a: 2 }]);
      const [sps, setSps] = useState(60);

      // decimals controls
      const [sameDP, setSameDP] = useState(true);
      const [allDP, setAllDP] = useState('auto');
      const [dpT, setDpT] = useState('auto');
      const [dpX, setDpX] = useState('auto');
      const [dpV, setDpV] = useState('auto');
      const [dpA, setDpA] = useState('auto');
      const dec = v => (v==='auto'?null:parseInt(v,10));
      const decT = sameDP?dec(allDP):dec(dpT);
      const decX = sameDP?dec(allDP):dec(dpX);
      const decV = sameDP?dec(allDP):dec(dpV);
      const decA = sameDP?dec(allDP):dec(dpA);

      // tick step controls
      const [autoSteps, setAutoSteps] = useState(true);
      const [tStep, setTStep] = useState("");  // seconds
      const [xStep, setXStep] = useState("");  // meters
      const [vStep, setVStep] = useState("");  // m/s
      const [aStep, setAStep] = useState("");  // m/s^2
      const valOrNull = (s) => {
        const n = Number(s);
        return Number.isFinite(n) && n > 0 ? n : null;
      };
      const stepT = autoSteps ? null : valOrNull(tStep);
      const stepX = autoSteps ? null : valOrNull(xStep);
      const stepV = autoSteps ? null : valOrNull(vStep);
      const stepA = autoSteps ? null : valOrNull(aStep);

      const { tArr, xArr, vArr, aSteps } = useMemo(() =>
        integratePiecewise({
          x0:+x0||0, v0:+v0||0,
          segments: segments.map(s=>({duration:+s.duration||0,a:+s.a||0})),
          samplesPerSecond: Math.max(5, Math.min(240, +sps||60))
        }), [x0,v0,segments,sps]);

      const xData = tArr.map((t,i)=>[t,xArr[i]]);
      const vData = tArr.map((t,i)=>[t,vArr[i]]);
      const totalT = segments.reduce((a,b)=>a+(+b.duration||0),0);
      const aData = aSteps.length?aSteps:[[0,0],[Math.max(1,totalT),0]];

      const addSeg=()=>setSegments(s=>[...s,{duration:1,a:0}]);
      const rmSeg=i=>setSegments(s=>s.filter((_,j)=>j!==i));
      const updSeg=(i,k,v)=>setSegments(s=>s.map((seg,j)=>j===i?{...seg,[k]:v}:seg));

      return (
        <div className="grid" style={{gap:24}}>
          <header>
            <h1 className="title">Motion Graph Maker (Piecewise Constant Acceleration)</h1>
            <p className="subtitle">Enter x₀, v₀, and per-interval acceleration → export clean SVG/PNG graphs for worksheets.</p>
          </header>

          <div className="grid grid-2" style={{gap:16}}>
            <div className="card">
              <h3 style={{marginTop:0, marginBottom:10}}>Initial Conditions</h3>
              <div className="grid" style={{gridTemplateColumns:"repeat(3,1fr)", gap:12}}>
                <div><label>x₀ (m)</label><input type="number" value={x0} onChange={e=>setX0(e.target.value)} /></div>
                <div><label>v₀ (m/s)</label><input type="number" value={v0} onChange={e=>setV0(e.target.value)} /></div>
                <div><label>Sampling (pts/s)</label><input type="number" min="5" max="240" value={sps} onChange={e=>setSps(e.target.value)} /></div>
              </div>
            </div>

            <div className="card">
              <div className="row" style={{justifyContent:"space-between"}}>
                <h3 style={{marginTop:0}}>Time Segments (Δt, a)</h3>
                <button className="primary" onClick={addSeg}>+ Add segment</button>
              </div>
              <table>
                <thead><tr><th>#</th><th>Δt (s)</th><th>a (m/s²)</th><th></th></tr></thead>
                <tbody>
                  {segments.map((seg,i)=>(
                    <tr key={i}>
                      <td>{i+1}</td>
                      <td><input type="number" min="0" step="any" value={seg.duration} onChange={e=>updSeg(i,"duration", e.target.value)} /></td>
                      <td><input type="number" step="any" value={seg.a} onChange={e=>updSeg(i,"a", e.target.value)} /></td>
                      <td style={{textAlign:"right"}}><button onClick={()=>rmSeg(i)} disabled={segments.length===1}>Remove</button></td>
                    </tr>
                  ))}
                </tbody>
              </table>
              <div className="muted" style={{marginTop:8}}>Total time: <b>{(sameDP?dec(allDP):dec(dpT))===null?tArr.at(-1)?.toFixed(2):Number(tArr.at(-1)||0).toFixed((sameDP?dec(allDP):dec(dpT)))}</b> s</div>
            </div>
          </div>

          <div className="card">
            <h3 style={{marginTop:0}}>Axis label decimals</h3>
            <div className="row">
              <input id="sameDP" type="checkbox" checked={sameDP} onChange={e=>setSameDP(e.target.checked)} />
              <label for="sameDP" style={{margin:0}}>Use same decimals for all axes</label>
            </div>
            {sameDP ? (
              <div style={{maxWidth:220, marginTop:12}}>
                <label>All axes</label>
                <select value={allDP} onChange={e=>setAllDP(e.target.value)}>
                  <option value="auto">Auto</option><option value="0">0</option><option value="1">1</option>
                  <option value="2">2</option><option value="3">3</option><option value="4">4</option>
                </select>
              </div>
            ) : (
              <div className="grid" style={{gridTemplateColumns:"repeat(4,1fr)", gap:12, marginTop:12}}>
                <div><label>t (time)</label><select value={dpT} onChange={e=>setDpT(e.target.value)}><option value="auto">Auto</option><option value="0">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option></select></div>
                <div><label>x (position)</label><select value={dpX} onChange={e=>setDpX(e.target.value)}><option value="auto">Auto</option><option value="0">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option></select></div>
                <div><label>v (velocity)</label><select value={dpV} onChange={e=>setDpV(e.target.value)}><option value="auto">Auto</option><option value="0">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option></select></div>
                <div><label>a (acceleration)</label><select value={dpA} onChange={e=>setDpA(e.target.value)}><option value="auto">Auto</option><option value="0">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option></select></div>
              </div>
            )}
          </div>

          <div className="card">
            <h3 style={{marginTop:0}}>Axis tick steps (optional)</h3>
            <div className="row">
              <input id="autoSteps" type="checkbox" checked={autoSteps} onChange={e=>setAutoSteps(e.target.checked)} />
              <label for="autoSteps" style={{margin:0}}>Use automatic tick steps</label>
            </div>
            {!autoSteps && (
              <div className="grid" style={{gridTemplateColumns:"repeat(4,1fr)", gap:12, marginTop:12}}>
                <div><label>t step (s)</label><input type="number" step="any" min="0" placeholder="Auto" value={tStep} onChange={e=>setTStep(e.target.value)} /></div>
                <div><label>x step (m)</label><input type="number" step="any" min="0" placeholder="Auto" value={xStep} onChange={e=>setXStep(e.target.value)} /></div>
                <div><label>v step (m/s)</label><input type="number" step="any" min="0" placeholder="Auto" value={vStep} onChange={e=>setVStep(e.target.value)} /></div>
                <div><label>a step (m/s²)</label><input type="number" step="any" min="0" placeholder="Auto" value={aStep} onChange={e=>setAStep(e.target.value)} /></div>
              </div>
            )}
            <div className="muted" style={{marginTop:8}}>Leave any field blank (or set “Use automatic”) to use nice automatic tick spacing.</div>
          </div>

          <div className="grid" style={{gap:16}}>
            <Chart
              data={xData}
              xLabel="time (s)"
              yLabel="position (m)"
              title="Position vs Time"
              decimalsX={decT}
              decimalsY={decX}
              tickStepX={stepT}
              tickStepY={stepX}
            />
            <Chart
              data={vData}
              xLabel="time (s)"
              yLabel="velocity (m/s)"
              title="Velocity vs Time"
              decimalsX={decT}
              decimalsY={decV}
              tickStepX={stepT}
              tickStepY={stepV}
            />
            <Chart
              data={aData}
              xLabel="time (s)"
              yLabel="acceleration (m/s²)"
              title="Acceleration vs Time"
              decimalsX={decT}
              decimalsY={decA}
              tickStepX={stepT}
              tickStepY={stepA}
            />
          </div>

          <footer className="muted">
            Tip: Use whole-number Δt and a for tidy tick marks. PNG paste crisply into Google Docs/Slides.
          </footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("app")).render(<App />);
  </script>
</body>
</html>
